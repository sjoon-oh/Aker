diff --git a/AnnService/CMakeLists.txt b/AnnService/CMakeLists.txt
index 0330796..5b2dd29 100644
--- a/AnnService/CMakeLists.txt
+++ b/AnnService/CMakeLists.txt
@@ -10,6 +10,17 @@ set(SpdkLibPrefix ${Spdk}/lib/libspdk_)
 set(DpdkLibPrefix ${Dpdk}/lib/librte_)
 set(SPDK_LIBRARIES -Wl,--whole-archive ${SpdkLibPrefix}bdev_nvme.a ${SpdkLibPrefix}bdev.a ${SpdkLibPrefix}nvme.a ${SpdkLibPrefix}vfio_user.a ${SpdkLibPrefix}sock.a ${SpdkLibPrefix}dma.a ${SpdkLibPrefix}notify.a ${SpdkLibPrefix}accel.a ${SpdkLibPrefix}event_bdev.a ${SpdkLibPrefix}event_accel.a ${SpdkLibPrefix}vmd.a ${SpdkLibPrefix}event_vmd.a ${SpdkLibPrefix}event_sock.a ${SpdkLibPrefix}event_iobuf.a ${SpdkLibPrefix}event.a ${SpdkLibPrefix}env_dpdk.a ${SpdkLibPrefix}log.a ${SpdkLibPrefix}thread.a ${SpdkLibPrefix}rpc.a ${SpdkLibPrefix}init.a ${SpdkLibPrefix}jsonrpc.a ${SpdkLibPrefix}json.a ${SpdkLibPrefix}trace.a ${SpdkLibPrefix}util.a ${DpdkLibPrefix}mempool.a ${DpdkLibPrefix}mempool_ring.a ${DpdkLibPrefix}eal.a ${DpdkLibPrefix}ring.a ${DpdkLibPrefix}telemetry.a ${DpdkLibPrefix}bus_pci.a ${DpdkLibPrefix}kvargs.a ${DpdkLibPrefix}pci.a -Wl,--no-whole-archive dl rt isal ${IsalLCrypto} uuid)
 
+#
+# Setting TopKache path
+find_library(TOPKACHE_LIB NAMES topkache PATHS ../../../build/lib)
+if (TOPKACHE_LIB)
+    message(STATUS "Found TopKache: ${TOPKACHE_LIB}")
+    include_directories(${PROJECT_SOURCE_DIR}/../../inc) 
+    # check the include include_directories
+else()
+    message(FATAL_ERROR "TopKache library not found!")
+endif()
+
 include_directories(${AnnService})
 include_directories(${Zstd}/lib)
 include_directories(${Spdk}/include)
@@ -44,18 +55,18 @@ if(${CMAKE_CXX_COMPILER_ID} STREQUAL "GNU")
     target_compile_options(DistanceUtils PRIVATE -mavx2 -mavx -msse -msse2 -mavx512f -mavx512bw -mavx512dq -fPIC)
 endif()
 
-find_package(RocksDB CONFIG)
-if((DEFINED RocksDB_DIR) AND RocksDB_DIR)
-    list(APPEND RocksDB_LIBRARIES RocksDB::rocksdb)
-    find_package(uring)
-    set(uring_LIBRARIES "")
-    message (STATUS "Found RocksDB ${RocksDB_VERSION}")
-    message (STATUS "RocksDB: ${RocksDB_DIR}")
-else()
-    set(RocksDB_LIBRARIES "")
-    set(uring_LIBRARIES "")
-    message (FATAL_ERROR "Could not find RocksDB!")
-endif()
+# find_package(RocksDB CONFIG)
+# if((DEFINED RocksDB_DIR) AND RocksDB_DIR)
+#     list(APPEND RocksDB_LIBRARIES RocksDB::rocksdb)
+#     find_package(uring)
+#     set(uring_LIBRARIES "")
+#     message (STATUS "Found RocksDB ${RocksDB_VERSION}")
+#     message (STATUS "RocksDB: ${RocksDB_DIR}")
+# else()
+#     set(RocksDB_LIBRARIES "")
+#     set(uring_LIBRARIES "")
+#     message (FATAL_ERROR "Could not find RocksDB!")
+# endif()
 
 find_package(TBB REQUIRED)
 if (TBB_FOUND)
@@ -63,9 +74,9 @@ if (TBB_FOUND)
 endif()
 
 add_library (SPTAGLib SHARED ${SRC_FILES} ${HDR_FILES})
-target_link_libraries (SPTAGLib DistanceUtils ${RocksDB_LIBRARIES} ${uring_LIBRARIES} libzstd_shared ${NUMA_LIBRARY} tbb ${SPDK_LIBRARIES})
+target_link_libraries (SPTAGLib DistanceUtils ${RocksDB_LIBRARIES} ${uring_LIBRARIES} libzstd_shared ${NUMA_LIBRARY} tbb ${SPDK_LIBRARIES} ${TOPKACHE_LIB})
 add_library (SPTAGLibStatic STATIC ${SRC_FILES} ${HDR_FILES})
-target_link_libraries (SPTAGLibStatic DistanceUtils ${RocksDB_LIBRARIES} ${uring_LIBRARIES} libzstd_static ${NUMA_LIBRARY_STATIC} tbb ${SPDK_LIBRARIES})
+target_link_libraries (SPTAGLibStatic DistanceUtils ${RocksDB_LIBRARIES} ${uring_LIBRARIES} libzstd_static ${NUMA_LIBRARY_STATIC} tbb ${SPDK_LIBRARIES} ${TOPKACHE_LIB})
 if(${CMAKE_CXX_COMPILER_ID} STREQUAL "GNU")
     target_compile_options(SPTAGLibStatic PRIVATE -fPIC)
 endif()
@@ -75,40 +86,40 @@ install(TARGETS SPTAGLib SPTAGLibStatic
   ARCHIVE DESTINATION lib
   LIBRARY DESTINATION lib)
 
-if (NOT LIBRARYONLY)
-    file(GLOB SERVER_HDR_FILES ${AnnService}/inc/Server/*.h ${AnnService}/inc/Socket/*.h)
-    file(GLOB SERVER_FILES ${AnnService}/src/Server/*.cpp ${AnnService}/src/Socket/*.cpp)
-    add_executable (server ${SERVER_FILES} ${SERVER_HDR_FILES})
-    target_link_libraries(server ${Boost_LIBRARIES} SPTAGLibStatic)
-
-    file(GLOB CLIENT_HDR_FILES ${AnnService}/inc/Client/*.h ${AnnService}/inc/Socket/*.h)
-    file(GLOB CLIENT_FILES ${AnnService}/src/Client/*.cpp ${AnnService}/src/Socket/*.cpp)
-    add_executable (client ${CLIENT_FILES} ${CLIENT_HDR_FILES})
-    target_link_libraries(client ${Boost_LIBRARIES} SPTAGLibStatic)
-
-    file(GLOB AGG_HDR_FILES ${AnnService}/inc/Aggregator/*.h ${AnnService}/inc/Socket/*.h ${AnnService}/inc/Server/QueryParser.h)
-    file(GLOB AGG_FILES ${AnnService}/src/Aggregator/*.cpp ${AnnService}/src/Socket/*.cpp ${AnnService}/src/Server/QueryParser.cpp)
-    add_executable (aggregator ${AGG_FILES} ${AGG_HDR_FILES})
-    target_link_libraries(aggregator ${Boost_LIBRARIES} SPTAGLibStatic)
-
-    file(GLOB BUILDER_FILES ${AnnService}/src/IndexBuilder/*.cpp)
-    add_executable (indexbuilder ${BUILDER_FILES})
-    target_link_libraries(indexbuilder ${Boost_LIBRARIES} SPTAGLibStatic)
-
-    file(GLOB SEARCHER_FILES ${AnnService}/src/IndexSearcher/*.cpp)
-    add_executable (indexsearcher ${SEARCHER_FILES})
-    target_link_libraries(indexsearcher ${Boost_LIBRARIES} SPTAGLibStatic)
-    
-    file(GLOB QUANTIZER_HDR_FILES ${AnnService}/inc/Quantizer/*.h)
-    file(GLOB QUANTIZER_FILES ${AnnService}/src/Quantizer/*.cpp)
-    add_executable (quantizer ${QUANTIZER_FILES} ${QUANTIZER_HDR_FILES})
-    target_link_libraries(quantizer ${Boost_LIBRARIES} SPTAGLibStatic)
-
-    install(TARGETS server client aggregator indexbuilder indexsearcher quantizer
-      RUNTIME DESTINATION bin
-      ARCHIVE DESTINATION lib
-      LIBRARY DESTINATION lib)
-endif()
+# if (NOT LIBRARYONLY)
+#     file(GLOB SERVER_HDR_FILES ${AnnService}/inc/Server/*.h ${AnnService}/inc/Socket/*.h)
+#     file(GLOB SERVER_FILES ${AnnService}/src/Server/*.cpp ${AnnService}/src/Socket/*.cpp)
+#     add_executable (server ${SERVER_FILES} ${SERVER_HDR_FILES})
+#     target_link_libraries(server ${Boost_LIBRARIES} SPTAGLibStatic)
+# 
+#     file(GLOB CLIENT_HDR_FILES ${AnnService}/inc/Client/*.h ${AnnService}/inc/Socket/*.h)
+#     file(GLOB CLIENT_FILES ${AnnService}/src/Client/*.cpp ${AnnService}/src/Socket/*.cpp)
+#     add_executable (client ${CLIENT_FILES} ${CLIENT_HDR_FILES})
+#     target_link_libraries(client ${Boost_LIBRARIES} SPTAGLibStatic)
+# 
+#     file(GLOB AGG_HDR_FILES ${AnnService}/inc/Aggregator/*.h ${AnnService}/inc/Socket/*.h ${AnnService}/inc/Server/QueryParser.h)
+#     file(GLOB AGG_FILES ${AnnService}/src/Aggregator/*.cpp ${AnnService}/src/Socket/*.cpp ${AnnService}/src/Server/QueryParser.cpp)
+#     add_executable (aggregator ${AGG_FILES} ${AGG_HDR_FILES})
+#     target_link_libraries(aggregator ${Boost_LIBRARIES} SPTAGLibStatic)
+# 
+#     file(GLOB BUILDER_FILES ${AnnService}/src/IndexBuilder/*.cpp)
+#     add_executable (indexbuilder ${BUILDER_FILES})
+#     target_link_libraries(indexbuilder ${Boost_LIBRARIES} SPTAGLibStatic)
+# 
+#     file(GLOB SEARCHER_FILES ${AnnService}/src/IndexSearcher/*.cpp)
+#     add_executable (indexsearcher ${SEARCHER_FILES})
+#     target_link_libraries(indexsearcher ${Boost_LIBRARIES} SPTAGLibStatic)
+#     
+#     file(GLOB QUANTIZER_HDR_FILES ${AnnService}/inc/Quantizer/*.h)
+#     file(GLOB QUANTIZER_FILES ${AnnService}/src/Quantizer/*.cpp)
+#     add_executable (quantizer ${QUANTIZER_FILES} ${QUANTIZER_HDR_FILES})
+#     target_link_libraries(quantizer ${Boost_LIBRARIES} SPTAGLibStatic)
+# 
+#     install(TARGETS server client aggregator indexbuilder indexsearcher quantizer
+#       RUNTIME DESTINATION bin
+#       ARCHIVE DESTINATION lib
+#       LIBRARY DESTINATION lib)
+# endif()
 
 file(GLOB_RECURSE SSD_SERVING_HDR_FILES ${AnnService}/inc/SSDServing/*.h)
 file(GLOB_RECURSE SSD_SERVING_FILES ${AnnService}/src/SSDServing/*.cpp)
@@ -120,28 +131,28 @@ file(GLOB_RECURSE USEFULTOOL_FILES ${AnnService}/src/UsefulTool/*.cpp)
 
 add_executable(ssdserving ${SSD_SERVING_HDR_FILES} ${SSD_SERVING_FILES})
 add_executable(spfresh ${SPFRESH_HDR_FILES} ${SPFRESH_FILES})
-add_executable(usefultool ${USEFULTOOL_FILES})
+# add_executable(usefultool ${USEFULTOOL_FILES})
 target_link_libraries(ssdserving SPTAGLibStatic ${Boost_LIBRARIES} ${RocksDB_LIBRARIES})
 target_link_libraries(spfresh SPTAGLibStatic ${Boost_LIBRARIES} ${RocksDB_LIBRARIES})
-target_link_libraries(usefultool SPTAGLibStatic ${Boost_LIBRARIES} ${RocksDB_LIBRARIES})
+# target_link_libraries(usefultool SPTAGLibStatic ${Boost_LIBRARIES} ${RocksDB_LIBRARIES})
 target_compile_definitions(ssdserving PRIVATE _exe)
 target_compile_definitions(spfresh PRIVATE _exe)
-target_compile_definitions(usefultool PRIVATE _exe)
+# target_compile_definitions(usefultool PRIVATE _exe)
 
 # for Test
 add_library(ssdservingLib ${SSD_SERVING_HDR_FILES} ${SSD_SERVING_FILES})
 target_link_libraries(ssdservingLib SPTAGLibStatic ${Boost_LIBRARIES})
 
-find_package(MPI)
-if (MPI_FOUND)
-    message (STATUS "Found MPI.")
-    message (STATUS "MPI Include Path: ${MPI_CXX_INCLUDE_PATH}")
-    message (STATUS "MPI Libraries: ${MPI_CXX_LIBRARIES}")
-    include_directories (${MPI_CXX_INCLUDE_PATH})
-    file(GLOB PARTITION_FILES ${AnnService}/src/BalancedDataPartition/*.cpp)
-    add_executable(balanceddatapartition ${PARTITION_FILES})
-    target_link_libraries(balanceddatapartition SPTAGLibStatic ${Boost_LIBRARIES} ${MPI_CXX_LIBRARIES})
-endif()
+# find_package(MPI)
+# if (MPI_FOUND)
+#     message (STATUS "Found MPI.")
+#     message (STATUS "MPI Include Path: ${MPI_CXX_INCLUDE_PATH}")
+#     message (STATUS "MPI Libraries: ${MPI_CXX_LIBRARIES}")
+#     include_directories (${MPI_CXX_INCLUDE_PATH})
+#     file(GLOB PARTITION_FILES ${AnnService}/src/BalancedDataPartition/*.cpp)
+#     add_executable(balanceddatapartition ${PARTITION_FILES})
+#     target_link_libraries(balanceddatapartition SPTAGLibStatic ${Boost_LIBRARIES} ${MPI_CXX_LIBRARIES})
+# endif()
 
 install(TARGETS ssdservingLib ssdserving
   RUNTIME DESTINATION bin
diff --git a/AnnService/inc/Core/Common/BKTree.h b/AnnService/inc/Core/Common/BKTree.h
index 5a91ebc..24999e7 100644
--- a/AnnService/inc/Core/Common/BKTree.h
+++ b/AnnService/inc/Core/Common/BKTree.h
@@ -9,6 +9,8 @@
 #include <vector>
 #include <shared_mutex>
 
+#include <mutex>
+
 #include "inc/Core/VectorIndex.h"
 
 #include "CommonUtils.h"
diff --git a/AnnService/inc/Core/VectorSet.h b/AnnService/inc/Core/VectorSet.h
index 24eb7c2..3b39af3 100644
--- a/AnnService/inc/Core/VectorSet.h
+++ b/AnnService/inc/Core/VectorSet.h
@@ -68,7 +68,7 @@ public:
 
     virtual void Normalize(int p_threads);
 
-private:
+// private:
     ByteArray m_data;
 
     VectorValueType m_valueType;
diff --git a/AnnService/inc/Helper/ConcurrentSet.h b/AnnService/inc/Helper/ConcurrentSet.h
index 1dfdf44..15acd55 100644
--- a/AnnService/inc/Helper/ConcurrentSet.h
+++ b/AnnService/inc/Helper/ConcurrentSet.h
@@ -14,6 +14,9 @@
 #include <concurrent_queue.h>
 #include <concurrent_unordered_set.h>
 #endif
+
+#include <mutex>
+
 namespace SPTAG
 {
     namespace Helper
diff --git a/AnnService/inc/Helper/DiskIO.h b/AnnService/inc/Helper/DiskIO.h
index b583d38..15fd23e 100644
--- a/AnnService/inc/Helper/DiskIO.h
+++ b/AnnService/inc/Helper/DiskIO.h
@@ -8,6 +8,7 @@
 #include <fstream>
 #include <string.h>
 #include <memory>
+#include <cstdint>
 
 namespace SPTAG
 {
diff --git a/AnnService/inc/SPFresh/SPFresh.h b/AnnService/inc/SPFresh/SPFresh.h
index 539e7ed..1bfe457 100644
--- a/AnnService/inc/SPFresh/SPFresh.h
+++ b/AnnService/inc/SPFresh/SPFresh.h
@@ -14,6 +14,72 @@
 #include <iostream>
 #include <fstream>
 
+/* 
+ * Add TopKache
+ */
+#include "Commons.hh"
+#include "utils/ParamParser.hh"
+
+#include "core/ResultCache2.hh"
+#include "utils/DefaultHash.hh"
+
+extern std::unique_ptr<topkache::ResultCache2> topkache_layer;
+extern topkache::result_cache_parameter_t topkache_parameter;
+
+SPTAG::BasicVectorSet* query_vectorset_handle;
+SPTAG::BasicVectorSet* vector_set_handle;
+
+std::vector<std::uint64_t> hashed_queries;
+std::vector<std::uint64_t> hashed_inserts;
+std::vector<std::uint64_t> hashed_deletes;
+
+
+size_t per_vector_size;
+
+float
+topkache_convfunc(
+    topkache::vector_data_t* src, 
+    size_t src_size, 
+    std::uint32_t dim, 
+    float* dst, 
+    std::uint8_t* aux)
+{
+    std::uint8_t* src_array = (std::uint8_t*)src;   // This is binary, thus we convert it to float.
+    float* dst_array = (float*)dst;
+
+    // Element size
+    assert(src_size % dim == 0);
+
+    SPTAG::VectorValueType* value_type = (SPTAG::VectorValueType*)aux;
+    switch (*value_type)
+    {
+        case (SPTAG::VectorValueType::Int8):
+            {
+                for (int i = 0; i < dim; i++)
+                    dst_array[i] = (std::int8_t)src_array[i];
+            }
+            break;
+        case (SPTAG::VectorValueType::UInt8):
+            {
+                for (int i = 0; i < dim; i++)
+                    dst_array[i] = (std::uint8_t)src_array[i];
+            }
+            break;
+        // case (SPTAG::VectorValueType::Int16):
+        //     break;
+        case (SPTAG::VectorValueType::Float):
+            {
+                // It is the same size, thus we just do memcpy to dst
+                std::memcpy(dst_array, src_array, src_size);
+            }
+            break;
+        default:
+            assert(0);
+    }
+
+    return true;
+}
+
 using namespace SPTAG;
 
 namespace SPTAG {
@@ -273,18 +339,201 @@ namespace SPTAG {
                     p_index->Initialize();
                     StopWSPFresh threadws;
                     size_t index = 0;
+
+#pragma region topkache-search-prepare
+
+                    std::int32_t skipped_counts = 0;
+
+                    SPTAG::SPANN::Options& p_opts = *(p_index->GetOptions());
+                    VectorValueType value_type = p_opts.m_valueType;
+        
+                    struct ResultTemplate {
+                        std::int32_t        vid;
+                        float               dist;
+                    };
+
+                    // Prepare data
+                    size_t vector_list_size = topkache_parameter.vector_list_size;
+                    struct ResultTemplate** vector_data_list 
+                        = new struct ResultTemplate*[vector_list_size];
+    
+                    for (int j = 0; j < vector_list_size; j++)
+                    {
+                        vector_data_list[j] = (new struct ResultTemplate);
+                        std::memset(vector_data_list[j], 0, sizeof(struct ResultTemplate));
+                    }
+    
+                    topkache::Vector2** vectors = new topkache::Vector2*[vector_list_size];
+                    for (int j = 0; j < p_internalResultNum; j++)
+                    {
+                        vectors[j] = new topkache::Vector2();                   // New vector
+                        vectors[j]->setVecData(
+                            (topkache::vector_data_t*)vector_data_list[j]);     // Set vector data
+                    }
+
+#pragma endregion
+
                     while (true)
                     {
                         index = queriesSent.fetch_add(1);
                         if (index < numQueries)
                         {
                             double startTime = threadws.getElapsedMs();
+
+#pragma region topkache-get
+                            QueryResult& query_result = p_results[index];
+
+
+                            // First, we need to get the result from the topkache
+                            std::uint64_t hashed_query_id = hashed_queries[index];
+
+                            bool similar_entry = false;
+                            bool is_invalid = false;
+
+                            topkache::vector_data_t* raw_query_data = (topkache::vector_data_t*)query_result.GetTarget();
+                            
+                            // Change the query vector to float_query
+                            topkache::float_qvec_t float_query = {
+                                .vector_id = hashed_query_id,
+                                .vector_data = raw_query_data,
+                                .vector_dim = topkache_parameter.vector_dim,
+                                .vector_data_size = topkache_parameter.vector_data_size,
+                                .conversion_function = topkache_convfunc,
+                                .aux = (std::uint8_t*)(&value_type)
+                            };
+
+                            topkache::result_cache_entry_t* found_entry 
+                                = topkache_layer->simGetCEntry(
+                                    float_query, similar_entry, is_invalid, 
+                                    [&](topkache::vector_data_t* vector1, topkache::vector_data_t* vector2, size_t dimension) -> float {
+                                        float distance = 0;
+                                        
+                                        // Here, the first vector1 is the float_query.vector_data, thus we ignore the value.
+                                        // Second vector2 is the found data, thus we use the saved vector data.
+                                        distance = COMMON::DistanceUtils::ComputeDistance(
+                                            (const ValueType*)raw_query_data,
+                                            (const ValueType*)vector2,
+                                            (DimensionType)dimension,
+                                            DistCalcMethod::L2                      // We fix the method for now
+                                        );
+
+                                        return distance;
+                                    }
+                            );
+
+                            if (found_entry != nullptr) 
+                            {
+                                for (int result_i = 0; result_i < p_internalResultNum; result_i++)
+                                {
+                                    struct ResultTemplate* vector_data 
+                                        = (struct ResultTemplate*)(found_entry->vector_slot_ref_list[result_i]->getVecData());
+                                    query_result.SetResult(result_i, vector_data->vid, vector_data->dist);
+                                }
+
+                                // If the entry is similar one, we link it to the query result
+                                if (similar_entry)
+                                {
+                                    topkache::Vector2* query_vector = new topkache::Vector2(topkache_parameter.vector_data_size);
+
+                                    query_vector->setVecId(hashed_query_id);
+                                    query_vector->setVecVersion(0);
+
+                                    // We do not record the raw vector data in this case.
+                                    std::memcpy(
+                                        query_vector->getVecData(), 
+                                        query_vectorset_handle->GetVector(index),
+                                        topkache_parameter.vector_data_size
+                                    );
+
+                                    topkache::result_cache_entry_t* new_entry 
+                                        = topkache_layer->makeCEntry(query_vector, vector_list_size, nullptr);                                            
+
+                                    topkache_layer->linkCEntry(new_entry, found_entry->query_vector->getVecId());
+                                }
+                                topkache_layer->freeCEntry(found_entry);
+
+                                // Count the result time
+                                double endTime = threadws.getElapsedMs();
+                                double exEndTime = threadws.getElapsedMs();
+
+                                p_stats[index].m_exLatency = exEndTime - endTime;
+                                p_stats[index].m_totalLatency = p_stats[index].m_totalSearchLatency = exEndTime - startTime;
+
+                                skipped_counts++;
+                                continue;
+                            }
+                            
                             p_index->GetMemoryIndex()->SearchIndex(p_results[index]);
                             double endTime = threadws.getElapsedMs();
 
                             p_stats[index].m_totalLatency = endTime - startTime;
 
                             p_index->SearchDiskIndex(p_results[index], &(p_stats[index]));
+
+#pragma region topkache-mgmt
+
+                            // It is time to add the result to the topkache_layer
+                            for (int result_i = 0; result_i < vector_list_size; result_i++)
+                            {
+                                size_t id = p_results[index].GetResult(result_i)->VID;
+                                vector_data_list[result_i]->vid = p_results[index].GetResult(result_i)->VID;      // Set VID
+                                vector_data_list[result_i]->dist = p_results[index].GetResult(result_i)->Dist;    // Set distance
+
+                                vectors[result_i]->setVecId(p_results[index].GetResult(result_i)->VID);
+                                vectors[result_i]->setVecVersion(0);
+
+                                vectors[result_i]->setDistance(p_results[index].GetResult(result_i)->Dist);
+                            }
+
+                            topkache::Vector2* query_vector = new topkache::Vector2(topkache_parameter.vector_data_size);
+                            
+                            query_vector->setVecId(hashed_queries[index]);
+                            query_vector->setVecVersion(0);
+
+                            raw_query_data = (topkache::vector_data_t*)query_result.GetTarget();
+                            std::memcpy(query_vector->getVecData(), raw_query_data, topkache_parameter.vector_data_size);
+
+                            // Change here from query vector to float_query
+                            float_query = {
+                                .vector_id = query_vector->getVecId(),
+                                .vector_data = query_vector->getVecData(),
+                                .vector_dim = topkache_parameter.vector_dim,
+                                .vector_data_size = topkache_parameter.vector_data_size,
+                                .conversion_function = topkache_convfunc,
+                                .aux = (std::uint8_t*)(&value_type)
+                            };
+
+                            topkache::result_cache_entry_t* new_entry = topkache_layer->makeCEntry(
+                                query_vector, vector_list_size, vectors
+                            );
+
+                            new_entry->min_distance = vector_data_list[0]->dist;
+                            new_entry->max_distance = vector_data_list[vector_list_size - 1]->dist;
+
+                            bool insert_success = topkache_layer->insertCEntry2(
+                                query_vector->getVecId(), new_entry, float_query 
+                            );
+
+                            // Consume the aged entry
+                            topkache_layer->consumeAgedWLEntry(
+                                [&](topkache::vector_data_t* vector1, topkache::vector_data_t* vector2, size_t dimension) -> float {
+                                    float distance = 0;
+                                    
+                                    // Here, the first vector1 is the float_query.vector_data, thus we ignore the value.
+                                    // Second vector2 is the found data, thus we use the saved vector data.
+                                    distance = COMMON::DistanceUtils::ComputeDistance(
+                                        (const ValueType*)raw_query_data,
+                                        (const ValueType*)vector2,
+                                        (DimensionType)dimension,
+                                        DistCalcMethod::L2                      // We fix the method for now
+                                    );
+
+                                    return distance;
+                                }
+                            );
+
+#pragma endregion
+
                             double exEndTime = threadws.getElapsedMs();
 
                             p_stats[index].m_exLatency = exEndTime - endTime;
@@ -587,6 +836,24 @@ namespace SPTAG {
                 if (avgStatsNum == 0) return;
                 int numQueries = querySet->Count();
 
+#pragma region topkache-query-hash-1
+
+                query_vectorset_handle = (BasicVectorSet*)querySet.get();
+
+                std::int32_t dim = query_vectorset_handle->m_dimension;
+                per_vector_size = query_vectorset_handle->m_perVectorDataSize;
+
+                // Record the query vectors to hash
+                for (int i = 0; i < numQueries; i++)
+                {
+                    const char* raw_vector = (const char*)query_vectorset_handle->GetVector(i);
+
+                    std::uint64_t hashed = topkache::default_hash(raw_vector, per_vector_size);
+                    hashed_queries.push_back(hashed);
+                }
+
+#pragma endregion
+
                 std::vector<QueryResult> results(numQueries, QueryResult(NULL, internalResultNum, false));
 
                 if (showStatus) LOG(Helper::LogLevel::LL_Info, "Searching: numThread: %d, numQueries: %d, searchTimes: %d.\n", numThreads, numQueries, avgStatsNum);
@@ -622,6 +889,9 @@ namespace SPTAG {
                         OutputResult<ValueType>(p_opts.m_searchResult + std::to_string(second), results, p_opts.m_resultNum);
                     }
                 }
+
+                query_vectorset_handle = nullptr;
+                hashed_queries.clear();
             }
 
             void LoadUpdateMapping(std::string fileName, std::vector<SizeType>& reverseIndices)
@@ -766,6 +1036,43 @@ namespace SPTAG {
                                 p_index->AddIndexSPFresh(vectorSet->GetVector(insertSet[index]), 1, p_opts.m_dim, &mapping[insertSet[index]]);
                             else
                                 p_index->AddIndexSPFresh(vectorSet->GetVector(index), 1, p_opts.m_dim, &mapping[insertSet[index]]);
+
+#pragma region topkache-wlog-insert-1
+                            
+                            size_t vector_size = vectorSet->PerVectorDataSize();
+                            uint64_t hashed_id = hashed_inserts[index];
+
+                            VectorValueType value_type = p_opts.m_valueType;
+
+                            topkache::float_qvec_t float_vector = {
+                                hashed_id,
+                                reinterpret_cast<topkache::vector_data_t*>(vectorSet->GetVector(index)),
+                                vectorSet->Dimension(),
+                                vector_size,
+                                topkache_convfunc,
+                                (std::uint8_t*)(&value_type)
+                            };
+
+                            topkache_layer->insertWLEntry3(
+                                float_vector,
+                                [&](topkache::vector_data_t* vector1, topkache::vector_data_t* vector2, size_t dimension) -> float {
+                                    float distance = 0;
+                                    
+                                    // Here, the first vector1 is the float_query.vector_data, thus we ignore the value.
+                                    // Second vector2 is the found data, thus we use the saved vector data.
+                                    distance = COMMON::DistanceUtils::ComputeDistance(
+                                        (const ValueType*)vector1,
+                                        (const ValueType*)vector2,
+                                        (DimensionType)dimension,
+                                        DistCalcMethod::L2                      // We fix the method for now
+                                    );
+
+                                    return distance;
+                                }
+                            );
+
+#pragma endregion
+
                             auto insertEnd = std::chrono::high_resolution_clock::now();
                             latency_vector[index] = std::chrono::duration_cast<std::chrono::microseconds>(insertEnd - insertBegin).count();
                         }
@@ -850,6 +1157,11 @@ namespace SPTAG {
                             //     LOG(Helper::LogLevel::LL_Info,"VID meta no found: %d\n", deleteSet[index]);
                             //     exit(1);
                             // }
+#pragma region topkache-delete-1
+
+                            uint64_t hashed_id = hashed_deletes[index];
+                            topkache_layer->markVecDeleted(hashed_id);
+#pragma endregion
 
                             auto deleteEnd = std::chrono::high_resolution_clock::now();
                             latency_vector[index] = std::chrono::duration_cast<std::chrono::microseconds>(deleteEnd - deleteBegin).count();
@@ -953,6 +1265,26 @@ namespace SPTAG {
 
                     bool showStatus = false;
 
+#pragma region topkache-prehash-1
+
+                    // Hash for inserts
+                    for (int i = 0; i < updateSize; i++)
+                    {
+                        const char* raw_vector = (const char*)vectorSet->GetVector(insertSet[i]);
+                        std::uint64_t hashed_id = topkache::default_hash(raw_vector, per_vector_size);
+                        hashed_inserts.push_back(hashed_id);
+                    }
+
+                    // Hash for deletes
+                    for (int i = 0; i < updateSize; i++)
+                    {
+                        const char* raw_vector = (const char*)vectorSet->GetVector(deleteSet[i]);
+                        std::uint64_t hashed_id = topkache::default_hash(raw_vector, per_vector_size);
+                        hashed_deletes.push_back(hashed_id);
+                    }
+
+#pragma endregion
+
                     std::future<void> delete_future;
                     if (!p_opts.m_stressTest) {
                         delete_future =
@@ -1018,6 +1350,9 @@ namespace SPTAG {
                         StableSearch(p_index, numThreads, querySet, vectorSet, searchTimes, p_opts.m_queryCountLimit, internalResultNum, truthFileName, p_opts, sw.getElapsedSec());
                     }
                     p_index->OpenMerge();
+
+                    hashed_deletes.clear();
+                    hashed_inserts.clear();
                 }
             }
 
diff --git a/AnnService/src/SPFresh/main.cpp b/AnnService/src/SPFresh/main.cpp
index 6aaebca..ca1ed8f 100644
--- a/AnnService/src/SPFresh/main.cpp
+++ b/AnnService/src/SPFresh/main.cpp
@@ -12,7 +12,17 @@
 #include "inc/Core/Common/TruthSet.h"
 
 #include "inc/SPFresh/SPFresh.h"
- 
+
+/* 
+ * Add TopKache
+ */
+#include "Commons.hh"
+#include "utils/ParamParser.hh"
+#include "core/ResultCache2.hh"
+
+std::unique_ptr<topkache::ResultCache2> topkache_layer;
+topkache::result_cache_parameter_t topkache_parameter;
+
 using namespace SPTAG;
 
 // switch between exe and static library by _$(OutputType) 
@@ -26,6 +36,25 @@ int main(int argc, char* argv[]) {
 		exit(-1);
 	}
 
+	// Add the TopKache parameter
+	if (argc < 3)
+	{
+		LOG(Helper::LogLevel::LL_Error, "topkache paramter?\n");
+		exit(-1);
+	}
+
+	{
+		std::string parameter_path = argv[2];
+
+		topkache::ParameterParser parser(parameter_path);
+		topkache_parameter = parser.getParameter();
+
+		topkache_layer.reset(new topkache::ResultCache2(topkache_parameter));
+
+		LOG(Helper::LogLevel::LL_Info, 
+			"TopKache layer initialized, using {}\n", parameter_path.c_str());
+	}
+
 	auto ret = SSDServing::SPFresh::UpdateTest(argv[1]);
 	return ret;
 }
diff --git a/CMakeLists.txt b/CMakeLists.txt
index b8802a4..33e73f3 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -102,6 +102,10 @@ else()
     message (FATAL_ERROR "Could no find openmp!")
 endif()
 
+set(BOOST_ROOT "/opt/boost_1_86")
+set(Boost_INCLUDE_DIR "/opt/boost_1_86/include")
+set(Boost_LIBRARY_DIR "/opt/boost_1_86/lib")
+
 find_package(Boost 1.66 COMPONENTS system thread serialization wserialization regex filesystem)
 if (Boost_FOUND)
     include_directories (${Boost_INCLUDE_DIR})
@@ -114,9 +118,9 @@ else()
     message (FATAL_ERROR "Could not find Boost >= 1.67!")
 endif()
 
-option(GPU "GPU" ON)
+option(GPU "GPU" OFF)
 option(LIBRARYONLY "LIBRARYONLY" OFF)
-option(ROCKSDB "ROCKSDB" ON)
+# option(ROCKSDB "ROCKSDB" OFF)
 
 if (ROCKSDB)
     add_definitions(-DROCKSDB)
@@ -125,6 +129,6 @@ endif()
 add_subdirectory (ThirdParty/zstd/build/cmake)
 
 add_subdirectory (AnnService)
-add_subdirectory (Test)
-add_subdirectory (GPUSupport)
-add_subdirectory (Wrappers)
+# add_subdirectory (Test)
+# add_subdirectory (GPUSupport)
+# add_subdirectory (Wrappers)
